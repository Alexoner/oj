/**
 *
470. Implement Rand10() Using Rand7()
Medium

Given a function rand7 which generates a uniform random integer in the range 1 to 7, write a function rand10 which generates a uniform random integer in the range 1 to 10.

Do NOT use system's Math.random().



Example 1:

Input: 1
Output: [7]
Example 2:

Input: 2
Output: [8,4]
Example 3:

Input: 3
Output: [8,1,10]


Note:

rand7 is predefined.
Each testcase has one argument: n, the number of times that rand10 is called.


Follow up:

What is the expected value for the number of calls to rand7() function?
Could you minimize the number of calls to rand7()?

Accepted 14K Submissions 30.8K

SOLUTION
================================================================================

1. General method - K based number representation & conditional probability
Given randK, we can represent any integer n with
n = sum(a_i * k^(i-1)), i = 0, ..., M
where a_i in [0, K-1], M is the maximum number of digits of number n.


For any number p < n, call the randK function M times,  let x = (K based
number represented by M digits generated by andK).
Then, p(x=p|x<n)
    = p(x=p, x<n) / p(x<n)
    = p(x=p)/p(x<n)
    = p(x=p)/p(x<n)
    = (1/k^M)/(n/k^M)
    = 1/n
where k=7, m = ceil(log_7(10)) = 2;

To speed up,
p(x=p|x<n) = p (x=p|x<n)
           = p(x \in {p, 2p, ...p*floor(7^M/n)}|x < n * floor(7^M/n))
           = p(x \in {p,2p,3p,4p} | x < 10 * 4)
           = p(x<4|x<40)
,where 7^M/n = 7^2/10=4


 *
 */

// The rand7() API is already defined for you.
// int rand7();
// @return a random integer in the range 1 to 7

#include <debug.hpp>
#include <random>
#include <cmath>

auto rand7 = []() {
    return rand() % 7 + 1;
};

class Solution {
public:
    int rand10() {
        int result = 0;
        //result = rand10ConditonalProbabilityTrivial();
        result = rand10ConditonalProbability();
        //cout << result << endl;
        return result;
    }

    int rand10ConditonalProbabilityTrivial() {
        int m = std::ceil(std::log(10)/std::log(7)); // ceil(math.log_7(10)) = ceil(ln(10)/ln(7))
        int x = 0;
        while (true) {
            // infinite loop
            for (int i = 0; i < m; ++i) {
                x += (rand7() - 1) * pow(7, i); // least to most significant bit
            }
            if (x > 0 && x < 11) { // condition met
                return x; // starting from 1
            }
            else {
                x = 0;
            }
        }
    }

    int rand10ConditonalProbability() {
        int m = std::ceil(std::log(10)/std::log(7)); // m bits
        int c = std::floor(pow(7, m) / 10); // maximum multiplier of 10
        assert(m == 2);
        assert(c == 4);
        int x = 0;
        int i = 0;
        while (true) {
            // infinite loop
            for (; i < m; ++i) {
                x += (rand7() - 1) * pow(7, i);
            }
            if (x > 0 && x <= 10*c) { // condition met
                return x % 10 + 1; // starting from 1
            }
            else {
                 // FIXME: retain last m-1 bits, wrong probability?
                //--i;
                //x /= 7;

                i = 0; x = 0; // actually faster...
            }
        }
    }
};

int main(int argc, char *argv[])
{
    Solution solution;

    int N = 100000;
    vector<double> arr(10+1, 0);
    for (int i = 0; i < N; ++i) {
        int x = solution.rand10();
        assert(x <= 10); assert(x>0);
        arr[x] += 1.0/N;
    }
    cout << arr << endl;

    cout << "self test passed!" << endl;
    return 0;
}
