#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
31. Next Permutation

Implement next permutation, which rearranges numbers into the lexicographically next greater
permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie,
sorted in ascending order).

The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the
right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

SOLUTION:
    brute-force: TLE...
    lexicographical order:
        Find the first pair of two successive ascending numbers a[i] and a[i−1], from the right,
        which satisfy a[i] > a[i-1].
        Swap a[j] and a[i-1] where a[j]>a[i-1] and j >= i, a[j+1] < a[i-1].
        Reverse a[i:].

VARIANT:
    How about permutations of m given n numbers? A_{4}^{2}
    1,2,3 → 1,2,4
    1,3,2 → 1,3,4
    1,3,4 → 1,4,2

"""


class Solution(object):

    def nextPermutation(self, nums, cycle=True):
        """
        :type nums: List[int]
        :type cycle: whether to return the lowest possible order
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        if not nums:
            return
        n = len(nums)
        exist = False
        for i in range(n - 1, 0, -1):
            if nums[i] > nums[i - 1]:
                exist = True
                index_j = i
                # find the smallest a[j] that is larger than a[i-1]
                # TODO: maybe binary search can be used here?
                for j in range(i, n):
                    if nums[j] > nums[i - 1]:
                        index_j = j
                    else:
                        break
                nums[i - 1], nums[index_j] = nums[index_j], nums[i - 1]
                # turn the trailing sequence from descending to ascending order
                nums[i:] = reversed(nums[i:])
                break
            pass
        if not exist:
            nums[:] = reversed(nums)
        return nums if cycle else None

    # TODO: next permutation of k numbers given n numbers
    def nextPermutationK(self, permutation, nums):
        ''' next permutation of k numbers given n numbers.
        :type permutation: list[int], a permutation of which the successor will be returned
        :type nums: List[int], all nums

        Given 1, 2, 3, 4:
            1,2,3 → 1,2,4
            1,3,4 → 1,2,1
            1,3,2 → 1,3,4
            2,3,4 → 2,4,1
            3,2,4 → 3,4,1
            1,3,4 → 2,1,3

        Solutions:
            1. similar procedure with arithmetic addition with carry.
            2. by swapping objects of current permutation or with rest of all objects that
        not used by current permutation yet
        '''
        if not nums or permutation:
            return []
        n = len(nums)
        k = len(permutation)
        idx2num = dict(enumerate(set(nums)))
        num2dix = dict([(v, k) for k, v in idx2num])
        # TODO: use count dictionary(map) to deal with duplicate elements situation
        # idx2count = dict()

    def nextPermutationKAddWithCarry(self, permutation, nums):
        '''
        Method 1:
            Similar to arithmetic addition with carry, for each permutation, we increase
            the least significant place of the sequence by one. If the sum overflows, then we
            carry one to its more significant place to continue the increment process, until it
            produces no more carry. Then we get the next permutation. But if the most significant
            place still overflows, then the iteration is done, no next permutation exists except
            the first one with increasing order.
        '''
        pass

    def nextPermutationKSwapping(self, permutation, nums):
        '''
        1, 2, 3:
        1, 3 → 2, 1
        Method 2:
            Compare two possible initial swapping. one of which is generated by rearranging the
        permutation itself by just swapping its objects internally, and the other of which is
        acquired by rearranging the current permutation with all the objects, which is including
        the external objects, the complement, that are not used yet.
        '''
        # objects that are not in permutation, but in all nums
        k = len(permutation)
        complement = sorted(list(nums))
        for obj in permutation:
            complement.remove(obj)

        # rearrange by increment. Swap an object from right with a bigger one in the
        # complement set
        exist = False
        for i in range(k - 1, -1, -1):
            # the minimum index with larger object
            min_index_larger = None
            for j in range(len(complement)):
                if permutation[i] < complement[j] and (
                    not min_index_larger or complement[j] < complement[min_index_larger]):
                    min_index_larger = j
            if min_index_larger is not None:
                permutation[i], complement[min_index_larger] = complement[min_index_larger], permutation[i]
                permutation[i + 1:] = sorted(complement + permutation[i + 1:])[:k - i - 1]
                exist = True
                break

        if not exist:
            # print('internal swap, reorder the trailing!', permutation)
            # swap two objects in the permutation to gain a bigger more significant place
            for i in range(k - 2, -1, -1):
                if permutation[i] >= permutation[i + 1]:
                    continue
                exist = True
                min_index_larger = i + 1
                # find the smallest a[j] that is larger than a[i-1]
                # TODO: maybe binary search can be used here?
                for j in range(i + 1, k):
                    if permutation[j] > permutation[i]:
                        min_index_larger = j
                    else:
                        break
                # print('swapping: ',min_index_larger, permutation[min_index_larger], permutation[i])
                permutation[i], permutation[min_index_larger] = permutation[min_index_larger], permutation[i]
                permutation[i + 1:] = sorted(complement + permutation[i + 1:])[:k - i - 1]
                break

        if not exist:
            permutation[:] = sorted(nums)[:k]

        return permutation

def test():
    for nums in [[1, 2, 3],
                 [3, 2, 1],
                 [1, 1, 5],
                ]:
        Solution().nextPermutation(nums)
        print(nums)

    print(Solution().nextPermutationKSwapping([1, 3], [1, 2, 3]))
    print(Solution().nextPermutationKSwapping([2, 3], [1, 2, 3]))
    print(Solution().nextPermutationKSwapping([3, 2], [1, 2, 3]))
    print(Solution().nextPermutationKSwapping([2, 1], [1, 2, 3]))
    pass

if __name__ == '__main__':
    test()
